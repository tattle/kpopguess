<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<meta name="referrer" content="origin" />
<title>K-Pop MV Guess ‚Äî Fixed List + YouTube API</title>
<style>
  *{box-sizing:border-box}
  html,body{margin:0;padding:0;background:#000;color:#fff;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{min-height:100svh;max-width:960px;margin:0 auto;padding:3vw;display:flex;flex-direction:column}
  h1{margin:.2rem 0 .6rem;font-size:clamp(16px,4.5vw,22px)}
  .hud{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-bottom:8px}
  .pill{background:#111;border-radius:14px;padding:.7rem 0;text-align:center;font-weight:800;font-size:clamp(12px,3.2vw,15px)}
  .stage{position:relative;width:100%;aspect-ratio:16/9;background:#000;border-radius:12px;overflow:hidden}
  .mask-top{position:absolute;left:0;right:0;top:0;height:15%;background:#000;pointer-events:none}
  .overlay,.loading{position:absolute;inset:0;display:none;align-items:center;justify-content:center}
  .overlay{background:rgba(0,0,0,.55);z-index:3}
  .overlay button,.btn{border:none;background:#fff;color:#000;border-radius:12px;padding:10px 16px;font-weight:700;cursor:pointer}
  .loading{background:rgba(0,0,0,.4);z-index:2}
  .choices{display:grid;gap:10px;margin-top:12px}
  .choice{border:.3vw solid #333;background:#111;color:#fff;border-radius:12px;padding:12px 14px;text-align:left;font-size:clamp(13px,3.2vw,16px);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .choice.correct{background:#2e7d32}
  .choice.wrong{background:#b71c1c}
  .bar{display:flex;gap:10px;margin-top:10px;align-items:center}
  .btn:disabled{opacity:.6;cursor:not-allowed}
</style>
</head>
<body>
<div class="wrap">
  <h1>üéµ K-Pop MV Guess ‚Äî 60s</h1>

  <div class="hud">
    <div class="pill">‚è± <span id="time">60</span>s</div>
    <div class="pill">‚úÖ <span id="correct">0</span></div>
    <div class="pill">‚ùì <span id="questions">0</span></div>
  </div>

  <div class="stage">
    <div id="player" style="position:absolute;inset:0"></div>
    <div class="mask-top"></div>
    <div id="loading" class="loading"><div>Loading‚Ä¶</div></div>
    <div id="tap" class="overlay"><button id="tapBtn">Tap to start</button></div>
  </div>

  <div id="choices" class="choices"></div>

  <div class="bar">
    <button id="startBtn" class="btn">Start 60s</button>
  </div>
</div>

<!-- YouTube IFrame API -->
<script src="https://www.youtube.com/iframe_api"></script>
<script>
/** === CONFIG: put your YouTube Data API v3 key here (optional) === */
const YT_API_KEY = "AIzaSyDBB3J-vwLYe8Enbmi6SmNCB5NW4QJv5Dc";

/** === Curated K-Pop MV list (titles are your answer space) === */
const MV_LIST = [
  {id:"fE2h3lGlOsk", title:"ITZY ‚Äì WANNABE"},
  {id:"sVTy_wmn5SU", title:"NewJeans ‚Äì Super Shy"},
  {id:"IHNzOHi8sJs", title:"BLACKPINK ‚Äì DDU-DU DDU-DU"},
  {id:"gdZLi9oWNZg", title:"BLACKPINK ‚Äì How You Like That"},
  {id:"WPdWvnAAurg", title:"LE SSERAFIM ‚Äì ANTIFRAGILE"},
  {id:"ry3S5H3p8wE", title:"aespa ‚Äì Savage"},
  {id:"gOsM-DYAEhY", title:"TWICE ‚Äì Feel Special"},
  {id:"eXbu8dD1zNI", title:"IVE ‚Äì I AM"},
  {id:"wTOP-nRZ5Jk", title:"SEVENTEEN ‚Äì Super"},
];

/** === State === */
let player, ready=false, userGesture=false;
let timeLeft=60, timerId=null;
let totalQuestions=0, totalCorrect=0;
let current=null; // {qid, videoId, duration, t, options:[{text,correct}], correctIndex}
let roundToken = 0; // prevents race/mismatch
const durations = {}; // id -> seconds (filled from API or fallback)

const $ = id => document.getElementById(id);
const sleep = ms => new Promise(r=>setTimeout(r,ms));
const shuffle = a => {const x=a.slice(); for(let i=x.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [x[i],x[j]]=[x[j],x[i]]} return x;};
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
function setHUD(){ $("time").textContent=timeLeft; $("correct").textContent=totalCorrect; $("questions").textContent=totalQuestions; }
function showLoading(on){ $("loading").style.display = on?"flex":"none"; }

/** === IFrame API === */
function onYouTubeIframeAPIReady(){
  player = new YT.Player("player", {
    host:"https://www.youtube.com",
    width:"100%", height:"100%", videoId:"",
    playerVars:{ origin:location.origin, autoplay:1, mute:1, playsinline:1, controls:0, rel:0, modestbranding:1 },
    events:{
      onReady: () => { ready=true; maybeAutostart(); },
      onError: () => {
        // Soft-skip: just start another round (token prevents mismatches)
        safeStartRound();
      }
    }
  });
}
function maybeAutostart(){
  const isiOS = /(iPhone|iPad|iPod)/i.test(navigator.userAgent);
  if (isiOS && !userGesture) $("tap").style.display="flex";
}

/** === Optional: fetch real durations for MV_LIST === */
const isoToSec = iso => {const m=(iso||"").match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/); if(!m)return 0; return (+m[1]||0)*3600+(+m[2]||0)*60+(+m[3]||0);};
async function primeDurations(){
  // prefill with a sane default so game works without key
  MV_LIST.forEach(v => { if(!(v.id in durations)) durations[v.id] = 200; });

  if (!YT_API_KEY || /YOUR_YOUTUBE_API_KEY_HERE/.test(YT_API_KEY)) return; // skip if no key
  const ids = MV_LIST.map(v=>v.id).join(",");
  const u = new URL("https://www.googleapis.com/youtube/v3/videos");
  u.searchParams.set("key", YT_API_KEY);
  u.searchParams.set("part","contentDetails");
  u.searchParams.set("id", ids);

  try{
    const res = await fetch(u.toString());
    if(!res.ok) throw new Error("videos HTTP "+res.status);
    const j = await res.json();
    (j.items||[]).forEach(x=>{
      const sec = isoToSec(x.contentDetails?.duration);
      if (sec > 30) durations[x.id] = sec;
    });
  }catch(e){
    // ignore errors; fallback durations remain
    console.warn("primeDurations failed:", e);
  }
}

/** === Build ONE question from MV_LIST (no search) === */
function buildQuestion(){
  // pick 1 correct
  const correct = MV_LIST[Math.floor(Math.random()*MV_LIST.length)];
  // ensure 3 unique distractors by title
  const norm = s => (s||"").toLowerCase().replace(/\s+/g," ").trim();
  const seen = new Set([norm(correct.title)]);
  const distractors = [];
  for (const cand of shuffle(MV_LIST)) {
    if (cand.id === correct.id) continue;
    const n = norm(cand.title);
    if (seen.has(n)) continue;
    seen.add(n); distractors.push(cand.title);
    if (distractors.length >= 3) break;
  }
  // build option objects, then shuffle
  const optionObjs = [
    { text: correct.title, correct: true },
    ...distractors.slice(0,3).map(t => ({ text:t, correct:false }))
  ];
  const options = shuffle(optionObjs);
  const correctIndex = options.findIndex(o => o.correct);

  // random time (5%~95%) using known or fallback duration
  const dur = Math.max(60, durations[correct.id] || 200);
  const start = Math.floor(dur*0.05);
  const end   = Math.ceil (dur*0.95);
  const t = clamp(Math.floor(start + Math.random()*(end-start)), 1, Math.max(1, dur-1));

  // return a question with a unique token
  return { qid: ++roundToken, videoId: correct.id, duration: dur, t, options, correctIndex };
}

/** === Safe round starter (uses token to avoid mismatches) === */
async function safeStartRound(){
  if (timeLeft<=0) return;
  showLoading(true);

  // Build question & remember its token
  const q = buildQuestion();
  const myToken = q.qid;
  current = q;

  try{
    // Load video, seek to random second, then pause
    player.loadVideoById(q.videoId);

    // Try to gain control within ~3.5s
    let controlled = false;
    for (let i=0;i<35;i++){
      // if another round started, abort quietly
      if (myToken !== roundToken) return;
      const st = player.getPlayerState?.();
      if (st===1 || st===2){ // PLAYING / PAUSED
        try{
          player.seekTo(q.t, true);
          setTimeout(()=> { if (myToken===roundToken) player.pauseVideo(); }, 120);
        }catch{}
        controlled=true; break;
      }
      try{ player.playVideo(); }catch{}
      await sleep(100);
    }
    if (!controlled) {
      // If still not controlled (iOS gesture needed), show tap and exit
      if (!userGesture) { $("tap").style.display="flex"; return; }
    }

    // Only render if this question is still current
    if (myToken === roundToken) {
      renderChoices(q);
      totalQuestions++; setHUD();
    }
  } finally {
    if (myToken === roundToken) showLoading(false);
  }
}

/** === Render & answer (auto-advance) === */
function renderChoices(q){
  const box = $("choices");
  box.innerHTML = "";
  q.options.forEach((opt, i)=>{
    const btn = document.createElement("button");
    btn.className = "choice";
    btn.textContent = `${String.fromCharCode(65+i)}. ${opt.text}`;
    btn.onclick = () => choose(i, btn, q.qid); // pass token to verify
    box.appendChild(btn);
  });
}

function choose(i, btn, token){
  // If a newer round already started, ignore click
  if (token !== roundToken) return;

  const buttons = [...document.querySelectorAll(".choice")];
  buttons.forEach(b=> b.disabled = true);

  const picked = current.options[i];
  if (picked?.correct){
    totalCorrect++;
    btn.classList.add("correct");
  } else {
    btn.classList.add("wrong");
    const okIdx = current.correctIndex;
    if (buttons[okIdx]) buttons[okIdx].classList.add("correct");
  }
  setHUD();

  // Auto-advance after short delay (token prevents overlap)
  const myToken = token;
  setTimeout(()=>{
    // Only advance if this round is still the latest
    if (myToken === roundToken && timeLeft>0) safeStartRound();
  }, 800);
}

/** === Game control === */
function startGame(){
  if (!ready){ alert("YouTube is loading ‚Äî try again in a second."); return; }
  userGesture = true; $("tap").style.display="none";

  timeLeft = 60; totalQuestions = 0; totalCorrect = 0; setHUD();
  if (timerId) clearInterval(timerId);
  timerId = setInterval(()=>{
    timeLeft--; setHUD();
    if (timeLeft<=0){
      clearInterval(timerId); timerId=null;
      alert(`Time's up! ‚úÖ Correct: ${totalCorrect} / Questions: ${totalQuestions}`);
    }
  },1000);

  // Start first round safely
  safeStartRound();
}

/** === UI events === */
$("startBtn").onclick = () => startGame();
$("tapBtn").onclick   = () => { userGesture=true; $("tap").style.display="none"; startGame(); };

/** === Boot === */
primeDurations(); // best-effort; game works even if this fails
</script>
</body>
</html>
